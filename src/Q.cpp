/*! \mainpage Q - ChIP-seq peak caller
 * 
 * @authors  Peter Hansen <peter.hansen@charite.de>, Peter Nick Robinson <peter.robinson@charite.de>
 *
 *  
 * \section sec_intro Introduction
 *
 * This is the documentation of the implementation of a ChIP-seq peak
 * caller called <strong>Q</strong>, which uses a new approach for the
 * preprocessing of the input alignment. <strong>Q</strong> is implemented
 * in C++ using the <a href="http://www.seqan.de/">SeqAn</a> and
 * <a href="http://www.boost.org">boost</a> libraries.
 * 
 *
 * \section sec_implementation Implementation
 * 
 * For the implementation five basic operation units could be identified:
 * 	-# Parse command line (\ref Q_ParseCommandLine.h)
 * 	-# Read alignment files (\ref Q_ReadInFiles.h)
 * 	-# Detect signals (\ref Q_DetectSignals.h)
 * 	-# Evaluate signals (\ref Q_EvaluateSignals.h)
 * 		- Calculate p-values/score (\ref Q_EvaluateSignalsPvalue.h)
 * 		- Maximum bipartite matching (\ref Q_EvaluateSignalsMaximumBipartiteMatching.h)
 * 	-# Write results (\ref Q_WriteResults.h)
 * 
 * For each of these units there is one header file. These header files
 * are included by the driver file \ref Q.cpp which contains the main
 * function.
 *
 *  
 * \subsection sec_install_parse Parse command line
 *
 * The user interface was created using the
 * <a href="http://trac.seqan.de/wiki/Tutorial/ParsingCommandLineArguments">command line parser of seqan</a>.
 * Required input for <strong>Q</strong> is an alignment in sam/bam 
 * format, a minmal and maximal fragment length and a prefix for all 
 * output files that will be genertated.
 *
 * 
 * \subsection sec_install_read Read alignment files
 * 
 * The central data structure called \ref Chromosome, which
 * contains all information and results for a given chromosome which 
 * occurs in the header of the input alignment file. The structure
 * \ref Chromosome in turn contains a vector of structures called \ref
 * Hit. A \ref Hit correspods to a line a the alignment file, that is
 * a mapped read. Furthermore the structure \ref Chromosome contains
 * a vector of structures called \ref Summit. Each summit corresponds
 * to a ChIP-seq signal which is detected and evaluated by
 * <strong>Q</strong>.
 * 
 *  In \ref Q.cpp an empty vector of \ref Chromosome objects is declared,
 *  which is then filled by the function \ref ReadAlignmentFile. The
 * alignments are read using the 
 * <a href="http://trac.seqan.de/wiki/Tutorial/BasicSamBamIO">sam/bam reader of SeqAn</a>.
 * After the function \ref ReadAlignmentFile has finished, the vector of
 * \ref Chromosome obejects contains one object for each chromosome
 * that occurs in the sam/bam header. Each object has been assigned
 * a name, a length and all hits on the corresponding chromosome. The 
 * hits in \ref Chromosome::SUMMITS are sorted according position.
 * 
 * \todo Actually there should be a class Genome which contains a vector
 * of \ref Chromosome objects. The structures \ref Hit and \ref Summit 
 * should belong to a super class called Feature. This would be a nice
 * reusable structure for future work.
 * 
 *  
 * \subsection sec_install_detect Detect signals
 * 
 * In the main function in \ref Q.cpp it is iterated over all \ref
 * Chromosome objects. The function \ref getSummits detects for each
 * \ref Chromosome object all summits. After the function has finished
 * the vector \ref Chromosome::SUMMITS contains all detected summits.
 *
 * @todo Add a link to a detailed description on how summits are defined.
 *  
 * \subsection sec_install_evaluate Evaluate signals
 *
 * This is the main building part of this project.
 *  
 * The file \ref Q_EvaluateSignals.h contains three different fuctions
 * for counting hits and things similar to hits.
 * 
 * The file \ref Q_EvaluateSignalsPvalue.h contains everything which has
 * to with p-values. As for the counting there are different definitions
 * of scores.
 * 
 * The file \ref Q_EvaluateSignalsMaximumBipartiteMatching.h contains a
 * code snippet which is needed to determine the cardinality of a
 * <i>feasible set of qfrags</i> for a given summit.
 * 
 * 
 * \subsection sec_install_write Write results 
 *
 * After all summits on all \ref Chromosomes were evaluated the results
 * are written to files. Three files are written by three separate 
 * functions, which are defined in \ref Q_WriteResults.h:
 * 	-# A file called \ref Options::out_prefix -Q-chromosome-info.tab 
 * is generated by the function \ref writeChromosomeInfo. This file
 * contains global information for each chromosome.
 * 	-# A file called Options::out_prefix -Q-summit-info.tab is generated
 * by the function \ref writeSummitInfo. This
 * file contains all information available for each summit.
 * 	-# A file called \ref Options::out_prefix -Q-narrowPeak.bed is
 * generated by the function \ref writeNarrowPeak.
 * 
 * 
 * 
 */

/**
 * @file
 * @authors  Peter Hansen <peter.hansen@charite.de>, Peter Nick Robinson <peter.robinson@charite.de>
 * @version 1.1.1
 *
 * @section DESCRIPTION
 *
 * \brief This file is the driver file for Q.
 * 
 * The program is divided into operation units:
 * 	- 1. Read command line
 * 	- 2. Read files
 * 	- 3. Detect signals
 * 	- 4. Evaluate signals
 * 	- 5. Write results
 * 
 * There is one header file for each unit containing declarations and
 * definitions of everything what is assigned to an operation unit.
 * This is not common standard but a first step to structure the 
 * program.
 * 
 * Seqan headers are included where needed.
 * 
 */

#include "Q_ParseCommandLine.h"
#include "Q_ReadInFiles.h"
#include "Q_GetFragLength.h"
#include "Q_DetectSignals.h"
#include "Q_EvaluateSignalsCount.h"
#include "Q_EvaluateSignalsPvalue.h"
#include "Q_WriteResults.h"


#include <boost/unordered_map.hpp>
#include <boost/dynamic_bitset.hpp>
#include <seqan/parallel.h>
#include <cmath>
#include <bitset>  

bool compareSummitsChrByPvalue(const Summit_chr& a, const Summit_chr& b)
{
    return a.summit.p_value < b.summit.p_value;
}

int main(int argc, char const ** argv) 
{

	// Read command line
	// -----------------

	Options options;
	seqan::ArgumentParser::ParseResult res = parseCommandLine(options, argc, argv);
	if (res != seqan::ArgumentParser::PARSE_OK)
	{
		return res == seqan::ArgumentParser::PARSE_ERROR; // Exit with 1 if parsing was not successful or help has been used
	}

	if(options.verbose)
	{
		std::cout << "\n" << "Command line has been parsed..." << "\n";
	}
	
	
    // Read input files
	// ----------------
	
	std::vector<Chromosome> chromosome;
	int chr_num;
	
	int failed=ReadAlignmentFile(chromosome,chr_num,options.chip_sample,options.control_sample,options.keep_dup,options.thread_num);// add optional list of chromosomes
	if(failed)
	{
		std::cerr << "ERROR: Function 'ReadAlignmentFile' failed !" << "\n";
		return 1;
	}
	
	if(options.verbose)
	{
		std::cout << "Alignment files have been parsed..." << "\n";
	}


    // Write table for distribution of hits around summits and stop
	// ------------------------------------------------------------
	
	if(options.bed_hit_dist != "None")
	{
		if(options.verbose)
		{
			std::cout << "Peak calling will be skipped..." << "\n";
			std::cout << "Writing table for distribution of hits around summits..." << "\n";
		}
		
		failed=ReadBedFile(chromosome,options.bed_hit_dist);
		if(failed)
		{
			std::cerr << "ERROR: Function 'ReadBedFile' failed !" << "\n";
			return 1;
		}
		if(options.verbose)
		{
			std::cout << "Summit file has been parsed..." << "\n";
		}
		failed=writeHitDist(chromosome,options.bed_radius, toCString(options.out_prefix));
		if(failed)
		{
			std::cerr << "ERROR: Function 'writeHitDist' failed !" << "\n";
			return 1;
		}
		if(options.verbose)
		{
			std::cout << "...Done." << "\n\n";
		}
		return(0);
	}
	
	if(options.fragment_length_avg==-1)
	{
		if(options.verbose)
		{
			std::cout << "No average fragment length specified. Will guess it from the treatment data...\n";
		}

		options.fragment_length_avg=getFragLength(chromosome, options.step_num,options.thread_num,toCString(options.out_prefix));

		if(options.verbose)
		{
			std::cout << "\tGuess for average fragment length: " << options.fragment_length_avg << "\n";
			std::cout << "\tExecute 'Rscript " <<  options.out_prefix << "-Q-binding-characteristics.R' to generate a pdf of the strand shift plot.\n";
		}
	}

	options.lowerbound=options.fragment_length_avg-options.fragment_length_dev;
	options.upperbound=options.fragment_length_avg+options.fragment_length_dev;
	
	if(options.verbose)
	{
		std::cout << "\tSet q_min to " <<  options.lowerbound << "\n";
		std::cout << "\tSet q_max to " <<  options.upperbound << "\n";			
	}
	
	if(options.binding_characteristics_only)
	{
		return(0);
	}
	
	
	// Write BED files and stop
	// ------------------------
	
	if(options.write_bed != "None")
	{
		if(options.verbose)
		{
			std::cout << "Peak calling will be skipped..." << "\n";
			std::cout << "Writing BED files..." << "\n";
		}
		
		failed=writePlainShiftedExtendedReadsAndQfragsToBED(chromosome, options);
		if(failed)
		{
			std::cerr << "ERROR: Function 'writePlainShiftedExtendedReadsAndQfragsToBED' failed !" << "\n";
			return 1;
		}
		if(options.verbose)
		{
			std::cout << "...Done." << "\n\n";
		}
		return(0);
	}


	// Get summits
	// -----------
	
	int cutoff=0;

	SEQAN_OMP_PRAGMA(parallel for num_threads(options.thread_num))
	for(int i=0;i<chr_num;i++)
	{
		
		failed=getSummits(chromosome[i],options.lowerbound,options.upperbound,cutoff);
		if(failed)
		{
			std::cerr << "ERROR: Function 'getSummits' failed !" << "\n";
		}
	}
	
	if(options.verbose)
	{
		std::cout << "Summits have been determined..." << "\n";
	}


	// Evaluate summits
	// ----------------

	if(options.verbose)
	{
		std::cout << "Evaluate summits..." << "\n";
	}
	
	// get for each summit the qfrag coverage for the ChIP and control sample
	SEQAN_OMP_PRAGMA(parallel for num_threads(options.thread_num))
	for(int i=0;i<chr_num;i++)
	{
		failed=getQFragsCoverage(chromosome[i],options.lowerbound,options.upperbound);
		if(failed)
		{
			std::cerr << "ERROR: Function 'getQFragsCoverage' failed !" << "\n";
		}
	}	

	if(options.verbose)
	{
		std::cout << "\t" << "Numbers of qfrags that cover each summit position have been determined..." << "\n";
	}
	

	// Get for each summit the number of saturated positions (q_beg and q_end)
	SEQAN_OMP_PRAGMA(parallel for num_threads(options.thread_num))
	for(int i=0;i<chr_num;i++)
	{
		failed=getQfragEnds(chromosome[i],options.lowerbound,options.upperbound);
		if(failed)
		{
			std::cerr << "ERROR: Function 'getQfragEnds' failed !" << "\n";
		}
	}

	if(options.verbose)
	{
		std::cout << "\t" << "Numbers of saturated positions around summits (q_beg and q_end) have been determined..." << "\n";
	}


	// Calculate saturation-score for each summit
	SEQAN_OMP_PRAGMA(parallel for num_threads(options.thread_num))
	for(int i=0;i<chr_num;i++)
	{
		failed = get_saturation_score(chromosome[i],options.upperbound);
		if(failed)
		{
			std::cerr << "ERROR: Function 'get_saturation_score' failed !" << "\n";
		}
	}
	
	if(options.verbose)
	{
		std::cout << "\t" << "Saturation scores have been determined..." << "\n";
	}

	// calculate saturation-p-value
	int g_t_f=0;
	int g_t_r=0;
	int g_c_f=0;
	int g_c_r=0;
	int g_length=0;
	for(int i=0;i<chr_num;i++)
	{
		g_t_f=g_t_f+chromosome[i].f_hit_num_chip;
		g_t_r=g_t_r+chromosome[i].r_hit_num_chip;		
		g_c_f=g_c_f+chromosome[i].f_hit_num_ctrl;
		g_c_r=g_c_r+chromosome[i].r_hit_num_ctrl;
		g_length=g_length+chromosome[i].len;		
	}
	bool has_ctrl;
	if(options.control_sample=="None"){has_ctrl=false;}else{has_ctrl=true;}	
	SEQAN_OMP_PRAGMA(parallel for num_threads(options.thread_num))
	for(int i=0;i<chr_num;i++)
	{
		failed = get_saturation_pvalues(chromosome[i], options.lowerbound, options.upperbound, g_length, g_t_f, g_t_r, g_c_f, g_c_r, has_ctrl); // used this for validation
		if(failed)
		{
			std::cerr << "ERROR: Function 'get_all_pvalues_for_chromosome_global_success_prob' failed !" << "\n";
		}
	}
	
	if(options.verbose)
	{
		std::cout << "\t" << "Saturation p-values have been determined..." << "\n";
	}


	
	// correct for multiple testing using Benjamini-Hochberg
	// -----------------------------------------------------
	
	// put all summits into one vector of summit structs
	std::vector<Summit_chr> ALL_SUMMITS_CHR;
	int summits_total=0;
	for(int i=0;i<chr_num;i++)
	{
		for(int j=0;j<chromosome[i].sum_num;j++)
		{
			Summit_chr s;
			s.chr_name=chromosome[i].name;
			s.chr_length=chromosome[i].len;
			s.summit=chromosome[i].SUMMITS[j];
			ALL_SUMMITS_CHR.push_back(s);
			summits_total++;
		}
	}

	// sort summits by p-value
	sort(ALL_SUMMITS_CHR.begin(),ALL_SUMMITS_CHR.end(),compareSummitsChrByPvalue);

	// multiply each summit by (total number of summits)/rank
	for(int i=0;i<summits_total;i++)
	{
		ALL_SUMMITS_CHR[i].summit.q_value=ALL_SUMMITS_CHR[i].summit.p_value*((long double)summits_total/(i+1));
	}

	if(options.verbose)
	{
		std::cout << "\t" << "p-values have been adjusted for multiple testing..." << "\n";
	}	
	

	// Write Output
	// ------------
	
	// write chromosome information to chomosome-info-file
	failed=writeChromosomeInfoShort(options.out_prefix, options.out_chromosome_info_file, chromosome, chr_num, options.lowerbound, options.upperbound, options.keep_dup, options.fragment_length_avg);
	if(failed)
	{
		std::cerr << "ERROR: Function 'writeChromosomeInfo' failed !" << "\n";
		return 1;
	}

	// write summit file with all summit information
	failed=writeSummitInfo(options.out_summit_info_file, ALL_SUMMITS_CHR, options);
	if(failed)
	{
		std::cerr << "ERROR: Function 'writeSummitInfo' failed !" << "\n";
		return 1;
	}

	// write file in narrowPeak format
	failed=writeNarrowPeak(options.out_narrowPeak_file, ALL_SUMMITS_CHR, options.lowerbound, options); // lower bound performs better with IDR
	if(failed)
	{
		std::cerr << "ERROR: Function 'writeNarrowPeak' failed !" << "\n";
		return 1;
	}
	

	// write bedgraph files
	if(options.write_bedgraph_treatment)
	{
			writeBedGraph(chromosome,options.out_prefix, options.fragment_length_avg, false);
	}

	if(options.write_bedgraph_control)
	{
			writeBedGraph(chromosome,options.out_prefix, options.fragment_length_avg, true);
	}
	
	if(options.verbose)
	{
		std::cout << "Results have been written to files..." << "\n" << "Done." << "\n\n";
	}	
	return 0;
}
